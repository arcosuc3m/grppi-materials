\begin{frame}[t]{Maps on data sequences}
\begin{itemize}
  \item A \textgood{map} pattern applies an operation to every element in a
        a data set, generating a new data set.
  \vfill

  \pause
  \item \textgood{Unidimensional}:
  \vfill
\begin{tikzpicture}
\tikzset{
  label/.style={text centered, text=orange,font=\footnotesize,minimum width=1cm} ,
  transform/.style={rectangle,rounded corners,draw=black,fill=green!50,text=white,thick, text centered, font=\tiny, minimum width=0.75cm,minimum height=0.5cm},
  item/.style={rectangle,draw=black,fill=orange!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  result/.style={rectangle,draw=black,fill=blue!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  arrow/.style={->,thick,draw=black,font=\tiny},
}  
\node[item] (item1) {};
\node[item,right=0cm of item1] (item2) {};
\node[item,right=0cm of item2] (item3) {};
\node[item,right=0cm of item3] (item4) {};
\node[item,right=0cm of item4] (item5) {};
%
\node[result,below=1cm of item1] (ritem1) {};
\node[result,right=0cm of ritem1] (ritem2) {};
\node[result,right=0cm of ritem2] (ritem3) {};
\node[result,right=0cm of ritem3] (ritem4) {};
\node[result,right=0cm of ritem4] (ritem5) {};
%
\node[transform,below=0.25cm of item1,minimum width=0.5cm] (map1) {};
\node[transform,below=0.25cm of item2,minimum width=0.5cm] (map2) {};
\node[transform,below=0.25cm of item3,minimum width=0.5cm] (map3) {};
\node[transform,below=0.25cm of item4,minimum width=0.5cm] (map4) {};
\node[transform,below=0.25cm of item5,minimum width=0.5cm] (map5) {};
%
\draw[arrow] (item1) -- (map1);
\draw[arrow] (item2) -- (map2);
\draw[arrow] (item3) -- (map3);
\draw[arrow] (item4) -- (map4);
\draw[arrow] (item5) -- (map5);
%
\draw[arrow] (map1) -- (ritem1);
\draw[arrow] (map2) -- (ritem2);
\draw[arrow] (map3) -- (ritem3);
\draw[arrow] (map4) -- (ritem4);
\draw[arrow] (map5) -- (ritem5);
\end{tikzpicture}


%    \begin{itemize}
%      \item $S = x_1, x_2, \ldots x_n$
%      \item $map(S,f)$
%        \begin{itemize} 
%          \item $f(x_1), f(x_2), \ldots, f(x_n)$
%        \end{itemize}
%    \end{itemize}

  \vfill
  \pause
  \item \textgood{Multidimensional}:
  \vfill
\begin{tikzpicture}
\tikzset{
  label/.style={text centered, text=orange,font=\footnotesize,minimum width=1cm} ,
  transform/.style={rectangle,rounded corners,draw=black,fill=green!50,text=white,thick, text centered, font=\tiny, minimum width=0.75cm,minimum height=0.5cm},
  item/.style={rectangle,draw=black,fill=orange!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  result/.style={rectangle,draw=black,fill=blue!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  arrow/.style={->,thick,draw=black,font=\tiny},
}  
\node[item] (item1) {};
\node[item,right=0cm of item1] (item2) {};
\node[item,right=0cm of item2] (item3) {};
\node[item,right=0cm of item3] (item4) {};
\node[item,right=0cm of item4] (item5) {};
%
\node[item,right=1cm of item5] (bitem1) {};
\node[item,right=0cm of bitem1] (bitem2) {};
\node[item,right=0cm of bitem2] (bitem3) {};
\node[item,right=0cm of bitem3] (bitem4) {};
\node[item,right=0cm of bitem4] (bitem5) {};
%
\node[result,below=1.5cm of item4] (ritem1) {};
\node[result,right=0cm of ritem1] (ritem2) {};
\node[result,right=0cm of ritem2] (ritem3) {};
\node[result,right=0cm of ritem3] (ritem4) {};
\node[result,right=0cm of ritem4] (ritem5) {};
%
\node[transform,above=0.25cm of ritem1,minimum width=0.5cm] (map1) {};
\node[transform,above=0.25cm of ritem2,minimum width=0.5cm] (map2) {};
\node[transform,above=0.25cm of ritem3,minimum width=0.5cm] (map3) {};
\node[transform,above=0.25cm of ritem4,minimum width=0.5cm] (map4) {};
\node[transform,above=0.25cm of ritem5,minimum width=0.5cm] (map5) {};
%
\path[arrow](item1) -- (map1);
\path[arrow](bitem1) -- (map1);
\path[arrow](item2) -- (map2);
\path[arrow](bitem2) -- (map2);
\path[arrow](item3) -- (map3);
\path[arrow](bitem3) -- (map3);
\path[arrow](item4) -- (map4);
\path[arrow](bitem4) -- (map4);
\path[arrow](item5) -- (map5);
\path[arrow](bitem5) -- (map5);
%
\path[arrow](map1) -- (ritem1);
\path[arrow](map2) -- (ritem2);
\path[arrow](map3) -- (ritem3);
\path[arrow](map4) -- (ritem4);
\path[arrow](map5) -- (ritem5);
\end{tikzpicture}

%    \begin{itemize}
%      \item $S_k = x^k_1, x^k_2, \ldots, x^k_n$
%      \item $map(S_1, S_2, \ldots, S_m, f)$
%        \begin{itemize}
%          \item $f(x^1_1, x^2_1, \ldots, x^m_1), f(x^2_1, x^2_2, \ldots, x^m_2), \ldots$
%        \end{itemize}
%    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Single sequences mapping}
\begin{block}{Double all elements in vector sequentially}
\begin{lstlisting}
std::vector<double> double_elements(const std::vector<double> & v) 
{
  std::vector<double> res(v.size());
  grppi::sequential_execution seq;

  grppi::map(seq, v.begin(), v.end(), res.begin(), 
    [](double x) { return 2*x; });

  return res;
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Single sequences mapping}
\begin{block}{Double all elements in vector with OpenMP}
\begin{lstlisting}
std::vector<double> double_elements(const std::vector<double> & v) 
{
  std::vector<double> res(v.size());
  grppi::parallel_execution_omp omp;

  grppi::map(omp, v.begin(), v.end(), res.begin(), 
    [](double x) { return 2*x; });

  return res;
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Multiple sequences mapping}
\begin{block}{Add two vectors}
\begin{lstlisting}
template <typename Execution>
std::vector<double> add_vectors(const Execution & ex, 
                                const std::vector<double> & v1,
                                const std::vector<double> & v2) 
{
  auto size = std::min(v1.size(), v2.size());
  std::vector<double> res(size);

  grppi::map(ex, std::make_tuple(v1.begin(), v2.begin), v1.end(), 
    res.begin(),
    [](double x, double y) { return x+y; },
  );

  return res;
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Multiple sequences mapping}
\begin{block}{Add three vectors}
\begin{lstlisting}
template <typename Execution>
std::vector<double> add_vectors(const Execution & ex, 
                                const std::vector<double> & v1,
                                const std::vector<double> & v2,
                                const std::vector<double> & v3) 
{
  auto size = std::min(v1.size(), v2.size());
  std::vector<double> res(size);

  grppi::map(ex, std::make_tuple(v1.begin(), v2.begin(), v3.begin()), v1.end(), 
    res.begin(),
    [](double x, double y, double z) { return x+y+z; },
  );

  return res;
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Heterogeneous mapping}
\begin{itemize}
  \item The result can be from a different type.
\end{itemize}
\begin{block}{Complex vector from real and imaginary vectors}
\begin{lstlisting}
template <typename Execution>
std::vector<complex<double>> create_cplx(const Execution & ex,
                                         const std::vector<double> & re,
                                         const std::vector<double> & im)
{
  auto size = std::min(re.size(), im.size());
  std::vector<complex<double>> res(size);

  grppi::map(ex, std::make_tuple(re.begin(), im.begin()), re.end(), 
    res.begin(),
    [](double r, double i) -> complex<double> { return {r,i}; }
  );

  return res;
}
\end{lstlisting}
\end{block}
\end{frame}
