\begin{frame}[t]{Pipeline pattern}
\begin{itemize}
  \item A \textgood{pipeline} pattern allows processing a data stream where the
        computation may be divided in multiple stages.
    \begin{itemize}
      \item Each stage processes the data item generated in the previous stage
            and passes the produced result to the next stage.
    \end{itemize}
\end{itemize}
\vfill
\begin{center}
\begin{tikzpicture}
\tikzset{
  label/.style={text centered, text=orange,font=\footnotesize,minimum width=1cm} ,
  transform/.style={rectangle,rounded corners,draw=black,fill=green!50,text=white,thick, text centered, font=\tiny, minimum width=0.75cm,minimum height=0.5cm},
  item/.style={rectangle,draw=black,fill=orange!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  result/.style={rectangle,draw=black,fill=blue!70,text=white,thick, text centered, font=\tiny, minimum width=0.75cm},
  arrow/.style={->,thick,draw=black,font=\tiny},
}  
\node[transform] (stage1) {};
\node[transform,right=1cm of stage1] (stage2) {};
\node[transform,right=1cm of stage2] (stage3) {};
\node[transform,right=1cm of stage3] (stage4) {};
%
\path[arrow] (stage1) -- (stage2);
\path[arrow] (stage2) -- (stage3);
\path[arrow] (stage3) -- (stage4);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[t]{Standalone pipeline}
\begin{itemize}
  \item A \textmark{standalone} \textgood{pipeline} is a top-level pipeline.
    \begin{itemize}
      \item Invoking the pipeline translates into its execution.
    \end{itemize}

  \vfill\pause
  \item Given:
    \begin{itemize}
      \item A \textgood{generator} $g : \varnothing \mapsto T_1 \cup \varnothing$
      \item A sequence of \textgood{transformers} $t_i : T_i \mapsto T_{i+1}$
    \end{itemize}

  \vfill
  \item For every \textmark{non-empty} value generated by $g$, it evaluates:
    \begin{itemize}
      \item $t_n(t_{n-1}(\ldots t_1(g())))$
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Generators}
\begin{itemize}
  \item A generator $g$ is any callable C++ entity that:
    \begin{itemize}
      \item Takes no argument.
      \item Returns a value of type $T$ that may hold (or not) a value.
      \item Null value signals end of stream.
    \end{itemize}

  \vfill\pause
  \item The return value must be any type that:
    \begin{itemize}
      \item Is copy-constructible or move-constructible.
\begin{lstlisting}
T x = g();
\end{lstlisting}
      \pause
      \item Is contextually convertible to \cppkey{bool}
\begin{lstlisting}
if (x) { /*...*/ }
if (!x) { /*...*/ }
\end{lstlisting}
      \pause
      \item Can be derreferenced
\begin{lstlisting}
auto val = *x;
\end{lstlisting}
    \end{itemize}
  \vfill\pause
  \item The standard library offers an excellent candidate \cppid{std::experimental::optional<T>}.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Simple pipeline}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  grppi::pipeline(ex,
    [i=0,max=n] () mutable -> optional<int> {
      if (i<max) return i++;
      else return {};
    },
    [](int x) -> double { return x*x; },
    [](double x) { return 1/x; },
    [](double x) { cout << x << "\n"; }
  );
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Nested pipelines}
\begin{itemize}
  \item Pipelines may be nested.
  \vfill
  \item An inner pipeline:
    \begin{itemize}
      \item Does not take an execution policy.
      \item All stages are transformers (no generator).
      \item The last stage must also produce values.
    \end{itemize}
  \vfill
  \item The inner pipeline uses the same execution policy than the outer
        pipeline.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Nested pipelines}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  grppi::pipeline(ex,
    [i=0,max=n] () mutable -> optional<int> {
      if (i<max) return i++;
      else return {};
    },
    grppi::pipeline(
      [](int x) -> double { return x*x; },
      [](double x) { return 1/x; }),
    [](double x) { cout << x << "\n"; }
  );
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Piecewise pipelines}
\begin{itemize}
  \item A pipeline can be piecewise created.
\end{itemize}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  auto generator = [i=0,max=n] () mutable -> optional<int> {
    if (i<max) return i++; else return {};
  };
  auto inner = grppi::pipeline(
      [](int x) -> double { return x*x; },
      [](double x) { return 1/x; });
  auto printer = [](double x) { cout << x << "\n"; };

  grppi::pipeline(ex, generator, inner, printer);
}
\end{lstlisting}
\end{block}
\end{frame}
