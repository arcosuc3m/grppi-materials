\subsection{Pipeline pattern}

\begin{frame}[t]{Pipeline pattern}
\begin{itemize}
  \item A \textgood{pipeline} pattern allows processing a data stream where the
        computation may be divided in multiple stages.
    \begin{itemize}
      \item Each stage processes the data item generated in the previous stage
            and passes the produced result to the next stage.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Standalone pipeline}
\begin{itemize}
  \item A \textmark{standalone} \textgood{pipeline} is a top-level pipeline.
    \begin{itemize}
      \item Invoking the pipeline translates into its execution.
    \end{itemize}

  \vfill\pause
  \item Given:
    \begin{itemize}
      \item A generater $g : \varnothing \mapsto T_1 \cup \varnothing$
      \item A sequence of transformers $t_i : T_i \mapsto T_{i+1}$
    \end{itemize}

  \vfill\pause
  \item For every non-empty value generated by $g$, it evaluates:
    \begin{itemize}
      \item $f_n(f_{n-1}(\ldots f_1(g())))$
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Generators}
\begin{itemize}
  \item A generator $g$ is any callable C++ entity that:
    \begin{itemize}
      \item Takes no argument.
      \item Returns a value of type $T$ that may hold (or not) a value.
      \item Null value signals end of stream.
    \end{itemize}

  \vfill\pause
  \item The return value must be any type that:
    \begin{itemize}
      \item Is copy-constructible or move-constructible.
\begin{lstlisting}
T x = g();
\end{lstlisting}
      \pause
      \item Is contextually convertible to \cppkey{bool}
\begin{lstlisting}
if (x) { /*...*/ }
if (!x) { /*...*/ }
\end{lstlisting}
      \pause
      \item Can be derreferenced
\begin{lstlisting}
auto val = *x;
\end{lstlisting}
    \end{itemize}
  \vfill\pause
  \item The standard library offers an excellent candidate \cppid{std::experimental::optional<T>}.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Simple pipeline}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  grppi::pipeline(ex,
    [i=0,max=n] () mutable -> optional<int> {
      if (i<max) return i;
      else return {};
    },
    [](int x) -> double { return x*x; },
    [](double x) { return 1/x; },
    [](double x) { cout << x << "\n"; }
  );
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Nested pipelines}
\begin{itemize}
  \item Pipelines may be nested.
  \vfill
  \item An inner pipeline:
    \begin{itemize}
      \item Does not take an execution policy.
      \item All stages are transformers (no generator).
      \item The last stage must also produce values.
    \end{itemize}
  \vfill
  \item The inner pipeline uses the same execution policy than the outer
        pipeline.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Nested pipelines}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  grppi::pipeline(ex,
    [i=0,max=n] () mutable -> optional<int> {
      if (i<max) return i;
      else return {};
    },
    grppi::pipeline(
      [](int x) -> double { return x*x; },
      [](double x) { return 1/x; }),
    [](double x) { cout << x << "\n"; }
  );
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Piecewise pipelines}
\begin{itemize}
  \item A pipeline can be piecewise created.
\end{itemize}
\begin{block}{x -> x*x -> 1/x -> print}
\begin{lstlisting}
template <typename Execution>
void run_pipe(const Execution & ex, int n)
{
  auto generator = [i=0,max=n] () mutable -> optional<int> {
    if (i<max) return i; else return {};
  };
  auto inner = grppi::pipeline(
      [](int x) -> double { return x*x; },
      [](double x) { return 1/x; });
  auto printer = [](double x) { cout << x << "\n"; };

  grppi::pipeline(ex, generator, inner, printer);
}
\end{lstlisting}
\end{block}
\end{frame}
